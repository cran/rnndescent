<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Querying Data</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Querying Data</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(rnndescent)</span></code></pre></div>
<p>The usual pattern of usage for approximate nearest neighbors methods
is:</p>
<ol style="list-style-type: decimal">
<li>Build some kind of index with input data.</li>
<li>Query that index with new data to find the nearest neighbors of your
query.</li>
</ol>
<p>This is how e.g. <a href="https://github.com/spotify/annoy">Annoy</a>
and <a href="https://github.com/nmslib/hnswlib">hnswlib</a> work. If you
want just the k-nearest neighbors of the data you used to build the
index in step 1, then you can just pass that data as the query in step
2, but <code>rnndescent</code> provides some specialized functions for
this case that are slightly more efficient, see for example
<code>nnd_knn</code> and <code>rpf_knn</code>. Nonetheless, querying the
index with the original data can produce a more accurate result. See the
<a href="hubness.Rmd">hubness</a> vignette for an example of that.</p>
<p>Below we will see some of the options that <code>rnndescent</code>
has for querying an index.</p>
<p>For convenience, I will use all the even rows of the
<code>iris</code> data to build an index, and search using the odd
rows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>iris_even <span class="ot">&lt;-</span> iris[<span class="fu">seq_len</span>(<span class="fu">nrow</span>(iris)) <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>, ]</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>iris_odd <span class="ot">&lt;-</span> iris[<span class="fu">seq_len</span>(<span class="fu">nrow</span>(iris)) <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">1</span>, ]</span></code></pre></div>
<div id="brute-force" class="section level2">
<h2>Brute Force</h2>
<p>If your dataset is small enough, you can just use brute force to find
the neighbors. No index to build, no worry about how approximate the
results are:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>brute_nbrs <span class="ot">&lt;-</span> <span class="fu">brute_force_knn_query</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>)</span></code></pre></div>
<p>The format of <code>brute_nbrs</code> is the usual k-nearest
neighbors graph format, a list of two matrices, both of dimension
<code>(nrow(iris_odd), k)</code>. The first matrix, <code>idx</code>
contains the indices of the nearest neighbors, and the second matrix,
<code>dist</code> contains the distances to those neighbors (here I’ll
just show the first five results per row):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">lapply</span>(brute_nbrs, <span class="cf">function</span>(m) {</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="fu">head</span>(m[, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>])</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>})</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; $idx</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt; [1,]    9   20   14    4   25</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; [2,]   24    2   23   15    1</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; [3,]   19    9    4   20   14</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; [4,]   24    6   15    2   19</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; [5,]    2    7   24   23   15</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; [6,]   14   10    3   16   11</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; $dist</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt;           [,1]      [,2]      [,3]      [,4]      [,5]</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; [1,] 0.1000000 0.1414213 0.1414213 0.1732050 0.2236068</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; [2,] 0.1414213 0.2449490 0.2645753 0.3000001 0.3000002</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; [3,] 0.1414213 0.1732050 0.2236066 0.2449488 0.2449488</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a><span class="co">#&gt; [4,] 0.2236068 0.3000002 0.3162278 0.3316627 0.4123106</span></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a><span class="co">#&gt; [5,] 0.2999998 0.3464101 0.3605550 0.4242641 0.4690414</span></span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a><span class="co">#&gt; [6,] 0.2828429 0.3316626 0.3464102 0.3605551 0.3605553</span></span></code></pre></div>
</div>
<div id="random-projection-forests" class="section level2">
<h2>Random Projection Forests</h2>
<p>If you build a random projection forest with <code>rpf_build</code>,
you can query it with <code>rpf_knn_query</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>rpf_index <span class="ot">&lt;-</span> <span class="fu">rpf_build</span>(iris_even)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>rpf_nbrs <span class="ot">&lt;-</span> <span class="fu">rpf_knn_query</span>(</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="at">forest =</span> rpf_index,</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>)</span></code></pre></div>
<p>See the <a href="random-partition-forests.html">Random Partition
Forests vignette</a> for more.</p>
</div>
<div id="graph-search" class="section level2">
<h2>Graph Search</h2>
<p>See <span class="citation">(Dobson et al. 2023)</span> for an
overview of graph search algorithms, which can be described as a greedy
beam search over a graph: to find the nearest neighbors, you start at a
candidate in the graph, find the distance from that candidate to the
query point, and update the neighbor list of your query accordingly. If
the candidate made it into the neighbor list of the query, this seems
like a promising direction to go in, so add the candidate’s neighbors to
the list of candidates to explore. Repeat this until such a time as you
run out of candidates. You may want to explore the neighbors of the
candidate even if it doesn’t make it onto the current neighbor list, if
its distance is sufficiently small. How much tolerance you have for this
controls how much back-tracking you do and hence how much exploration
and the amount of time you spend in the search.</p>
<p><code>graph_knn_query</code> implements this search. At the very
least you must provide a <code>reference_graph</code> to search, the
<code>reference</code> data that built the <code>reference_graph</code>
(so we can calculate distances), <code>k</code> the number of neighbors
you want, and of course the <code>query</code> data:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>graph_nbrs <span class="ot">&lt;-</span> <span class="fu">graph_knn_query</span>(</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="at">reference_graph =</span> rpf_nbrs,</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>)</span></code></pre></div>
<p>If you aren’t using the <code>metric = &quot;euclidean&quot;</code>, you should
also provide the same <code>metric</code> that you used to build the
<code>reference_graph</code>. The default <code>metric</code> is always
<code>&quot;euclidean&quot;</code> for any function in <code>rnndescent</code> so
it’s not provided in the examples here.</p>
<p>There are some other parameters you will want to tweak in any real
world case that merit some deeper discussion.</p>
<div id="n_threads" class="section level3">
<h3><code>n_threads</code></h3>
<p><code>n_threads</code> controls how many threads to use in the
search. Be aware that <code>graph_knn_query</code> is designed for
<em>batch</em> parallelism, and each thread will be responsible for
searching a subset of the <code>query</code> points. This means that in
a streaming context, where queries to search are likely to arrive one at
a time, you won’t get any speed up from using multiple threads.</p>
</div>
<div id="epsilon" class="section level3">
<h3><code>epsilon</code></h3>
<p><code>epsilon</code> controls how much exploration of the neighbors
of a candidate to do, as suggested by <span class="citation">(Iwasaki
and Miyazaki 2018)</span>. The default value is <code>0.1</code>, which
is also the default of the <a href="https://github.com/yahoojapan/NGT/blob/main/python/README-ngtpy.md">NGT</a>
library. The larger the value, the more back-tracking is permitted. The
exact meaning of the value is related to how large a distance is
considered “close enough” the current neighbor list of the query to be
worth exploring.</p>
<p><code>epsilon = 0.1</code> means that the query-candidate distance is
allowed to be 10% larger than the largest distance in the neighbor list.
If you set <code>epsilon = 0.2</code>, for example, then the
query-candidate distance is allowed to be 20% higher than the largest
distance in the neighbor list and so on. If you set
<code>epsilon = 0</code> then you get a pure greedy search.</p>
<p>It’s hard to give a general rule for what value to set, because it’s
highly dependent on the distribution of distances in the dataset and
that is determined by the distance metric and the dimensionality of the
data itself. I recommend leaving this as the default, and only modifying
it if you find that the search is unreasonably slow (in which case make
<code>epsilon</code> smaller) or unreasonably inaccurate (in which case
make <code>epsilon</code> larger). Yes, not very helpful I know. In the
benchmarking done in <span class="citation">(Dobson et al. 2023)</span>
using a similar back-tracking method, <code>epsilon = 0.25</code> was
the maximum value used and in <span class="citation">(Wang et al.
2021)</span> <code>epsilon = 0.1</code> was used.</p>
</div>
<div id="init" class="section level3">
<h3><code>init</code></h3>
<p>This controls how the search is initialized. If you don’t provide
this, then <code>k</code> random neighbors per item in
<code>query</code> will be generated for you.</p>
<div id="neighbor-graph-input" class="section level4">
<h4>Neighbor Graph Input</h4>
<p>You may provide your own input for this. It should be in the neighbor
graph format, i.e. a list of two matrices, <code>idx</code> and
<code>dist</code>, as described above. Make sure that the
<code>dist</code> matrix contains the distances using the same
<code>metric</code> you will use in the search.</p>
</div>
<div id="neighbor-indices-only" class="section level4">
<h4>Neighbor Indices Only</h4>
<p>In fact, the <code>dist</code> matrix is optional. If you only
provide the <code>idx</code> matrix, then the <code>dist</code> matrix
will be calculated for you. If the <code>dist</code> matrix is already
available to you and it was generated by <code>rnndescent</code> then
there is no reason <em>not</em> to use it, but you could have neighbors
that come from:</p>
<ul>
<li>another nearest neighbor package and for some reason you don’t have
the distance</li>
<li>or you have indices from a different metric that you nonetheless
believe are a good guess for the “real” metric.</li>
</ul>
<p>A case where this might be worth experimenting with could be if you
can cheaply binarize your input data, i.e. convert it to 0/1 then to
<code>FALSE</code>/<code>TRUE</code>: you could then use the
<code>hamming</code> metric or another binary-specialized metric on that
input data. Even a brute force search can be very fast on this data.
This could be a good way to get a good guess for the real data.</p>
<p>This is a very contrived example with <code>iris</code>, but let’s do
it anyway:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>numeric_iris <span class="ot">&lt;-</span> iris[, <span class="fu">sapply</span>(iris, is.numeric)]</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>logical_iris <span class="ot">&lt;-</span> <span class="fu">sweep</span>(numeric_iris, <span class="dv">2</span>, <span class="fu">colMeans</span>(numeric_iris), <span class="st">&quot;&gt;&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>logical_iris_even <span class="ot">&lt;-</span> logical_iris[<span class="fu">seq_len</span>(<span class="fu">nrow</span>(logical_iris)) <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>, ]</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>logical_iris_odd <span class="ot">&lt;-</span> logical_iris[<span class="fu">seq_len</span>(<span class="fu">nrow</span>(logical_iris)) <span class="sc">%%</span> <span class="dv">2</span> <span class="sc">==</span> <span class="dv">1</span>, ]</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="fu">head</span>(logical_iris_even)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt;      Sepal.Length Sepal.Width Petal.Length Petal.Width</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; [1,]        FALSE       FALSE        FALSE       FALSE</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; [2,]        FALSE        TRUE        FALSE       FALSE</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; [3,]        FALSE        TRUE        FALSE       FALSE</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; [4,]        FALSE        TRUE        FALSE       FALSE</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt; [5,]        FALSE        TRUE        FALSE       FALSE</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; [6,]        FALSE        TRUE        FALSE       FALSE</span></span></code></pre></div>
<p>Do a brute force search on the binarized data:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>iris_logical_brute_nbrs <span class="ot">&lt;-</span> <span class="fu">brute_force_knn_query</span>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  <span class="at">query =</span> logical_iris_odd,</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="at">reference =</span> logical_iris_even,</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span>,</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="at">metric =</span> <span class="st">&quot;hamming&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>)</span></code></pre></div>
<p>Then pass the indices of the brute force search to
<code>graph_knn_query</code>, which will generate the Euclidean
distances for you:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>graph_nbrs <span class="ot">&lt;-</span> <span class="fu">graph_knn_query</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="at">reference_graph =</span> rpf_nbrs,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="at">init =</span> iris_logical_brute_nbrs<span class="sc">$</span>idx,</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>)</span></code></pre></div>
<p>Whether this is worth doing all depends on whether the time taken to
binarize the data followed by the initial search on the binary data (it
doesn’t have to be brute force) gives you a good enough guess to save
time in the “real” search with <code>graph_knn_query</code>.</p>
</div>
<div id="forest-initialization" class="section level4">
<h4>Forest initialization</h4>
<p>If you have previously built an RP Forest with the data you may also
use that to initialize the query. We can re-use <code>rpf_index</code>
here.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>forest_init_nbrs <span class="ot">&lt;-</span> <span class="fu">graph_knn_query</span>(</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="at">reference_graph =</span> rpf_nbrs,</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  <span class="at">init =</span> rpf_index,</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>)</span></code></pre></div>
<p>In general, the RP forest initialization is likely to be a better
initial guess than random, but in terms of a speed/accuracy trade-off,
using a large forest may not be the best choice. You may want to use
<code>rpf_filter</code> to reduce the size of the forest before using it
as an initial guess. In the <a href="https://github.com/lmcinnes/pynndescent">PyNNDescent</a> Python
package that <code>rnndescent</code> is based on, only one tree is used
for initializing query results.</p>
</div>
</div>
</div>
<div id="preparing-the-search-graph" class="section level2">
<h2>Preparing the Search Graph</h2>
<p>In all the examples so far, we have used the k-nearest neighbors
graph as the <code>reference_graph</code> input to
<code>graph_knn_query</code>. Is this actually a good idea? Probably
not! There is no guarantee that all the items in the original dataset
can actually be reached via the k-nearest neighbors graph. Some nodes
just aren’t very popular and may not be in the neighbor list of
<em>any</em> other item. That means you can never reach them via the
k-nearest neighbors graph, no matter how thoroughly you search it.</p>
<p>We can solve this problem by reversing all the edges in the graph and
adding them to the graph. So if you can get to item <code>i</code> from
item <code>j</code>, you can now get to item <code>j</code> from item
<code>i</code>. This solves one problem but adds some more which is that
just like some items are very unpopular, other items might be very
popular and appear often in the neighbor list of other items. Having a
large number of these edges in the graph can make the search very slow.
We therefore need to prune some of these edges.</p>
<p><code>prepare_search_graph</code> is a function that will take a
k-nearest neighbor graph and add edges to it to make it more useful for
a search. The procedure is based on the process described in <span class="citation">(Harwood and Drummond 2016)</span> and consists of:</p>
<ol style="list-style-type: decimal">
<li>Reversing all the edges in the graph.</li>
<li>“Diversifying” the graph by “occlusion pruning”. This considers
triplets of points, and removes long edges which are probably redundant.
For an item <span class="math inline">\(i\)</span> with neighbors <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> if the distances <span class="math inline">\(d_{pq} \lt d_{ip}\)</span> i.e. the neighbors are
closer to each other than they are to <span class="math inline">\(i\)</span>, then it is said that <span class="math inline">\(p\)</span> occludes <span class="math inline">\(q\)</span> and we don’t need both edges <span class="math inline">\(i \rightarrow p\)</span> and <span class="math inline">\(i \rightarrow q\)</span> – it’s likely that <span class="math inline">\(q\)</span> is in the neighbor list of <span class="math inline">\(p\)</span> or vice versa, so it’s unlikely that we
are doing any harm by getting rid of <span class="math inline">\(i
\rightarrow p\)</span>.</li>
<li>After occlusion pruning, if any item still has an excessive number
of edges, the longest edges are removed until the number of edges is
below the threshold.</li>
</ol>
<p>To control all this pruning the following parameters are
available:</p>
<div id="diversification-probability" class="section level3">
<h3>Diversification Probability</h3>
<p><code>diversify_prob</code> is the probability of a neighbor being
removed if it is found to be an “occlusion”. This should take a value
between <code>0</code> (no diversification) and <code>1</code> (remove
as many edges as possible). The default is <code>1.0</code>.</p>
<p>The <a href="https://papers.nips.cc/paper_files/paper/2019/hash/09853c7fb1d3f8ee67a61b6bf4a7f8e6-Abstract.html">DiskAnn/Vamana</a>
method’s pruning algorithm is almost identical but instead of a
probability, uses a related parameter called <code>alpha</code>, which
acts in the opposite direction: increasing <code>alpha</code> increases
the density of the graph. Why am I telling you this? The <a href="https://github.com/cmuparlay/pbbsbench/blob/9553d354b5cf18153d4ea6370664c383316174eb/benchmarks/ANN/pyNNDescent/pynn_index.h#L235">pbbsbench
implementation of PyNNDescent</a> uses <code>alpha</code> instead of
<code>diversify_prob</code> and in the accompanying paper <span class="citation">(Dobson et al. 2023)</span> they mention that the use
of <code>alpha</code> yields “modest improvements” – from context this
seems to mean relative to using <code>diversify_prob = 1.0</code>. I
can’t give an exact mapping between the two values unfortunately.</p>
</div>
<div id="degree-pruning" class="section level3">
<h3>Degree Pruning</h3>
<p><code>pruning_degree_multiplier</code> controls how many edges to
remove after the occlusion pruning relative to the number of neighbors
in the original nearest neighbor graph. The default is <code>1.5</code>
which means to allow as many as 50% more edge than the original graph.
So if the input graph was for <code>k = 15</code>, each item in the
search graph will have at most <code>15 * 1.5 = 22</code> edges.</p>
<p>Let’s see how this works on the <code>iris</code> neighbors:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>iris_search_graph <span class="ot">&lt;-</span> <span class="fu">prepare_search_graph</span>(</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">data =</span> iris_even,</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="at">graph =</span> rpf_nbrs,</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="at">diversify_prob =</span> <span class="fl">0.1</span>,</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>  <span class="at">pruning_degree_multiplier =</span> <span class="fl">1.5</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>)</span></code></pre></div>
<p>Because the returned search graph can contain different number of
edges per item, the neighbor graph format isn’t suitable. Instead you
get back a sparse matrix, specifically a <code>dgCMatrix</code>. Here’s
a histogram of how the edges are distributed:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>search_graph_edges <span class="ot">&lt;-</span> <span class="fu">diff</span>(iris_search_graph<span class="sc">@</span>p)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">hist</span>(search_graph_edges,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="at">main =</span> <span class="st">&quot;Distribution of search graph edges&quot;</span>, <span class="at">xlab =</span> <span class="st">&quot;# edges&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>)</span></code></pre></div>
<p><img src="data:image/png;base64,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TQIkQAIkYAkEcgnIlp4WEiABEiCBpAlQACSNjhFJgARIINgEKACC3X4sPQmQAAkkTYACIGl0jEgCJEACwSZAARDs9mPpSYAESCBpAhQASaNjRBIgARIINgEKgGC3H0tPAiRAAkkToABIGh0jkgAJkECwCVAABLv9WHoSIAESSJqApwCYM2eO3HbbbbJo0aKkM2FEEiABEiCBzCPgKQDKli0rH374of0O74gRI2TLli2ZVxOWiARIgARIIF8EPAXAGWecId9++6188cUX0rp1a3n44YelRo0a0qVLF5k4caLk5ubmK0MGJgESIAESyAwCngLAFBNf4ho5cqT897//lQkTJkiFChWkf//++iPseDPnd999Z4LylwRIgARIIAAEfAsAU5e1a9fKwoUL5auvvpJdu3ZJnTp1ZP78+XLaaafJ0KFDTTD+kgAJkAAJZDgBX6+D3rp1q7z55pvy6quvymeffSZVqlSRPn366OtGjRrpKr799tvSs2dP6dq1qzRt2jTDq83ikQAJkAAJeAqA2bNnS7t27TSpSy65RN5//325+OKLpUiRyKgdOnTQYTZt2kSqJEACJEACASAQ2YvHKXDJkiXl8ccfl969e0ulSpXihPjFqXjx4rJx40Y9O8gzED1IgARIgAQyhoDnHgA2f2+99Vb56KOP5Pvvv7cFv+GGGyI2fjEjwNIQDQmQAAmQQDAIeAoAVON3v/ud1vjBCB/GcRx9MOz0008XnAugIQESIAESCB4BTwGwYsUKmTVrlixZskTOOeccXcOcnBz59NNP5W9/+5vce++9cvDgweDVnCUmARIggZAT8BQAM2bMECwD1atXLwbVlVdeKXv37hWohtKQAAmQAAkEi4CnAGjQoIF8/vnnsm7dupiaTZ48WQoXLqxPBsd40oEESIAESCCjCXgKgJYtW0rVqlW13v/HH38s69evl5UrV8r48eNlyJAh0qNHDylRokRGV5KFIwESIAESiCXgqQZ63HHHybx586Rjx47Stm3biBS6d+8uzz77bIQbL0iABEiABIJBwFMAoBonnniiLF68WI/+v/76a73sg6Wh2rVrB6OWLCUJkAAJkEAMAV8CwMSqWbOm4I+GBEiABEgg+AR8CQAsAUHfH+v/8VQ+v/zyy+CTYA1IgARIIGQEPAUAtH8uuugiKVOmjLRq1UpKly4dMkSsLgmQAAlk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AhQAx4os080YAgsWLJCzzz7blif62nrQQgIhI0ABELIGD2N1v/zyS2nWrJmu+t69e2XZsmX2Oow8WGcSMAQoAAwJ/mYVge+//1538uj4p0yZIi+//LK+btGihRw+fFiuuOIKmTp1ap51fvHFF6Vp06ZSqlQpQZxJkyZFhF2zZo1cddVVUrVqVT27+OijjyL8cbF69WoZMGCAVK9eXc444wx58803pU+fPjJ27Fgbds+ePXLDDTdI7dq1pVKlStKlSxdZu3at9Yfl2Weflfr168vxxx8vTZo0kaeeeirCnxckkCyBIslGZDwSyGQCZcqUkd///veye/duwZLPXXfdJSeccILMnDlTcnNzpXfv3rrTjVeHJ554QgYNGiTdu3eXIUOGyKxZs6Rz587y7rvvSteuXQWbyvDbv3+/jBw5UjZt2iS9evWSI0eO2OTcYZ588knZvn273HjjjYIZSN26dXU4bEq3a9dOVq5cKddee63t3Js3by7fffedlCtXTiZPnqzj/elPf5Lf/OY3uiwDBw4U1K9///42P1pIICkC6iakIYGsJTBnzhxHdaS2fn/84x+dm2++2V5HW3bs2OGoztXp169fhFePHj0c1XFrt9GjRztFihRx1Ejdhnn11VehYuQ899xz2u2ZZ57R10r7yIZRMxHtNmzYMO2mZgT6WnXyNoyaETglS5Z07r33Xu1255132nxNICXMHDWjMZf8JYGkCXAJKCmxyUhBIfD111/LmWeeaYu7cOFCOeuss+x1tAXhd+7cKRiFY+Zg/k477TRZsWKFbN26VRAGS0snnniijd6zZ08pVOjXxwnxsPTTqFEjG6ZDhw5SunRpez179mw9ksfSj8kH+xMo36effqrDIR/k27FjR3n99dflp59+kscff1wvJdmEaCGBJAlwCShJcIyW2QS2bNkiTz/9tHzwwQdy6NAhuf/++3WBcR4AHS/W57t16yaNGzeOqAjcYW666Sb9G/0P/suXL5cqVapEeBUtWlSv4RtHdOStWrUyl/a3WrVq1o60IGywtBNtatWqpZ0uv/xyQbjHHntM71momYdAkEDd1J1WdHxek4AfAr8OWfyEZhgSCAgBbK6q5R9ZvHixXvOH/f3339cbwNjAxTXW7qMN1t1h4I80ov+wMVyzZk1RS0XRUXVY41ixYsW4YTCDMKZs2bKCjh77FNH5fPvttyaY3o9AWWfMmKE3jPGLPQgaEjhaAhQAR0uQ8TOSADpWjP6xMYulk48//liweQptHNjx1759+5iyN2zYULtBWKi1ePv31ltvyXXXXaeFCTRxsAz0888/2/josNGRG9OyZUuZP3++XrIxbl988YVs27bNXOrlIYzuEdfkVaJECbn11lutphA2kO+44w7BDOPCCy/UGkCYnWDJyL3pbBOlhQTyQYACIB+wGDRYBJYuXSo4nWs6daz/YwSfyEBDR234CtRAoX6JNXeoeN5yyy165F+8eHGtXQT10GuuuUZ36J988knMmjxUOxH23HPPFbVBLNAsgiaR20DzBzMOdPjTpk3TaakNYp33Oeeco4NC/RNCAGns2rVLCx4INiwvufcc3OnSTgK+CSS9fcyIJJDhBJS+vaNG4raU5513nqM6dXudl0V1+k7fvn21po96kBy11u4ofX5HqXDaKGoE7ihh4qjXS+hwgwcPdtSmr9UCQkC1eev89re/ddRSj9OgQQMHmkJKcDhqE9emow6pOWpGobWBkBbSVOv71h8W9eoK59RTT9VhVKfvXHDBBc6GDRsiwvCCBJIhkINIvqUFA5JAgAj8+OOPWlcfh6xgMCOA5o5bEydRdaDLrzpavU5v3iMUHR5r85gNYAnHbVatWqWXaIzOP/xwBgBhMbtQaqbu4HqmceDAAX2wLMLDdbF+/Xo9Y8CBMBoSSAUBCoBUUGQaJBBF4IUXXtCHu+bNm6dPEqNzVzr9Ancc8jrppJOiYvCSBNJPgAIg/cyZYwgIoMM3r5vA6yLwCmqocE6YMCHu5nMIkLCKGUiAAiADG4VFyh4CRh21cuXK+swBhAANCWQKAQqATGkJloMESIAE0kyAaqBpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCFAAZEpLsBwkQAIkkGYCFABpBs7sSIAESCBTCPw/yuu9I0ohrZEAAAAASUVORK5CYII=" /><!-- --></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">range</span>(search_graph_edges)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co">#&gt; [1]  7 22</span></span></code></pre></div>
<p>So most items have around about <code>k = 15</code> edges just like
the nearest neighbor graph. But some have have the maximum number of
edges and few have only 10 edges.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>search_nbrs <span class="ot">&lt;-</span> <span class="fu">graph_knn_query</span>(</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="at">query =</span> iris_odd,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  <span class="at">reference =</span> iris_even,</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>  <span class="at">reference_graph =</span> iris_search_graph,</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>  <span class="at">init =</span> rpf_index,</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>  <span class="at">k =</span> <span class="dv">15</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>)</span></code></pre></div>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-dobson2023scaling" class="csl-entry">
Dobson, Magdalen, Zheqi Shen, Guy E Blelloch, Laxman Dhulipala, Yan Gu,
Harsha Vardhan Simhadri, and Yihan Sun. 2023. <span>“Scaling Graph-Based
ANNS Algorithms to Billion-Size Datasets: A Comparative
Analysis.”</span> <em>arXiv Preprint arXiv:2305.04359</em>.
</div>
<div id="ref-harwood2016fanng" class="csl-entry">
Harwood, Ben, and Tom Drummond. 2016. <span>“Fanng: Fast Approximate
Nearest Neighbour Graphs.”</span> In <em>Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition</em>, 5713–22.
</div>
<div id="ref-iwasaki2018optimization" class="csl-entry">
Iwasaki, Masajiro, and Daisuke Miyazaki. 2018. <span>“Optimization of
Indexing Based on k-Nearest Neighbor Graph for Proximity Search in
High-Dimensional Data.”</span> <em>arXiv Preprint arXiv:1810.07355</em>.
</div>
<div id="ref-wang2021comprehensive" class="csl-entry">
Wang, Mengzhao, Xiaoliang Xu, Qiang Yue, and Yuxiang Wang. 2021.
<span>“A Comprehensive Survey and Experimental Comparison of Graph-Based
Approximate Nearest Neighbor Search.”</span> <em>arXiv Preprint
arXiv:2101.12631</em>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
